<!DOCTYPE html>
<html>
  <head>
    <title>Visão Computacional com Python</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

      /*Images full scale*/
      img{width: 100%; height:100%}

      /* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
        .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
      .right-column {
        width: 75%;
        float: right;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

layout: true
background-image: url(images/bgnd.png)
---
class: center, middle
![Center-aligned image](images/tdc.png)

# Visão computacional com OpenCV e Python

### Eduardo Henrique Arnold

### William Jamir Silva

---
# Agenda

- Visão Computacional
- Python e OpenCV
- Aquisição de imagens pela câmera
- Detecção de Marcadores
- Bordas e Contornos
- Perspectiva
- Threshold Adaptativo
- Identificação
- **[Bonus]** Computação Gráfica

---
class: center, middle
# Visão Computacional

???

"Visão computacional é a ciência responsável pela visão de uma máquina, pela forma como um computador enxerga o meio à sua volta,
extraindo informações significativas a partir de imagens capturadas por câmeras de vídeo, sensores, scanners, entre outros dispositivos.
Estas informações permitem reconhecer, manipular e pensar sobre os objetos que compõem uma imagem "
Ballard, Dana Harry, Computer Vision, PrenticeHall, 1982.

---
## Aplicação em tráfego urbano
![Center-aligned image](images/ex-traffic.png)

???

Aplicações de visão computacional estão em todas as partes, podemos encontrar em aplicações de tráfego urbano como por exeplo:
- Radares de velocidade e multas
- Tráfego inteligente / sensores de congestionamento

---
## Reconhecimento facial
![Center-aligned image](images/ex-face.jpg)

???
O reconhecimento facial é utilizado largamente em diversas aplicações, empresas como Facebook e Google utilizam-se dessa técnica para identificar rostos de pessoas em fotos de redes sociais. Temos também aplicações de vigilância onde uma camêra consegue identificar pessoas para extração de informações

---
## Aplicações Médicas -- Computerized Tomography
![:img 90%,center](images/ex-medicine.png)

???
A área de medicina tambem utiliza largamente visão computacional, diagnósticos médicos através da interpretação de uma radiografia já podem ser feitos sem a intervenção de um ser humano, como também contagem de células e identifcação de estrturas celulares.
---
# Bibliotecas

.left-column[
### Python 2.7
]

.right-column[
## Numpy
É utilizado como alternativa as estruturas de dados fornecidas nativamente pelo OpenCV em C++. O wrapper do OpenCV para Python fez essa opção pois é uma biblioteca consolidada e permite manipulação rápida de dados mesmo em Python.

![:img 40%,center](images/np.png)

]

???
O objetivo de se utilizar o Numpy é de expressasr images como arrays multidimensionais, o que ajuda computacionalmente a realizar cálculos numericos na imagem. É a alternativa Python para as estruturas de dados fornecidas pelo OpenCV nativamente em C++.
---
# Bibliotecas

.left-column[
### Python 2.7
### OpenCV 3.1
]

.right-column[
![:img 30%, center](images/ocv.png)
- Estruturas de dados básicas
- Processamento básico de imagens
- Imagem/Video I/O
- Análise de vídeo
- Detecção de objetos
- Calibração de câmera e mapeamento
- Aprendizado de máquina
- GUI
]

???
OpenCV é uma biblioteca de processamento de imagens com diversos algoritmos de visão computacional, desenvolvida em C/C++ também tem suporte para Java Python e Visual basic

---
#Objetivo final

![Center-aligned image](images/placeholder.jpg)

???
Nessa apresentação nosso objetivo é mostrar os passos necessários para alcançarmos a aplicação que é mostrado na figura desse slide.
---
#Noções de representação de imagem


![image](images/pixel.png)

```python
(b, g, r) = image[0, 0]12print "Pixel at (0, 0) - Red: %d, Green: %d, Blue: %d" % (r, g, b)
```

???
Se pensarmos na imagem como um conjunto de quadrados cada quadrado será um pixel. Os pixels podem ser representados em escala de cinza ou cores.
Em escala de cinza Zero é preto e 255 é branco e os valores intermediarios são os tons de cinzas
Em Cores os pixels são geralmente representados por core RGB, um valor para vermelho outra para verde e outro para azul, juntando esse tres valores temos nossos padroes de cores. Image [Linha][Coluna][RGB]

O OpenCV guarda esse valores na ordem inversa, Blue Green e Red
O eixo da imagem se inicia no topo esquerdo da image.

---
# Aquisição da imagem

```python
from cv2 import *
# initialize the camera
cam = VideoCapture(0)   # 0 -> index of camera
s, img = cam.read()
if s:    # frame captured without any errors
    namedWindow("cam-test",CV_WINDOW_AUTOSIZE)
    imshow("cam-test",img)
    waitKey(0)
    destroyWindow("cam-test")
    imwrite("filename.jpg",img) #save image
```
???
O primeiro passo para iniciarmos nossa aplicação é realizar a aquisição da imagem a ser processada.
A função é simples, é necessário o pacotev cv2 (OpenCV) onde iremos ter as funções que nos auxiliam com os dispositivos de imagens.

---
# Preprocessamento

##Resize
```python
import cv2
imagem = cv2.imread(args["imagem"])
dimensao = (150, 150)
Img_Redimensionada = cv2.resize(imagem, dimensao, interpolation = cv2.INTER_AREA)
cv2.imshow("Resized (Width)", resized)
```
##Grayscale
```python
    _, img = cam.read()
    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
```
???
Resize
Para o resize iremos utilizar cv2.resize, devemos prestar atenção no aspect ratio (proporção entre a largura e altura).
Na Quarta linha redimensionamos a imagem utilizando a nova largura e altura.
Após isso utilizamos o metodo de redimensionamento com um metodo de interpolação no terceiro argumento.
Opções disponiveis:
cv2.INTER_AREA
cv2.INTER_LINEAR
cv2.INTER_CUBIC
cv2.INTER_NEAREST.

GrayScale
Convertemos a imagem de RGB para Grayscale, porque convertemos para grayscale.
As cores possuem complexidades, multicanais em grayscale lidamos somente com um canal de imagem fazendo assim o processamento ser mais rapidos
Muitas das funções e algoritmos já desenvolvidos em openCV exigem que a imagem esteja em escala de cinza.
Para deteção de bordas o nivel de brilho da escala de cinza já é suficiente para deteção.
[Adicionar mais coisas?]

---
# Detecção dos marcadores

--
## Algoritmo de borda - Canny

--
## Detecção de contornos

--
## Filtragem de contornos

--
## Transformação de perspectiva

--
## Threshold adaptativo

--
## Identificação dos marcadores

---
# Aplicação de Realidade Aumentada
## Computação gráfica com OpenGL e Python


    </textarea>
    <script src="remark-latest.min.js"/></script>
    <script>
      /* Image scaling macro */
      remark.macros.img = function (percentage, align) {
        var url = this;
        return '<p style="text-align: '+align+'"><img src="' + url + '" style="width: ' + percentage + '" /></p>';
      };
      var slideshow = remark.create();
    </script>
  </body>
</html>
